# 中央处理器相关笔记

## MIPS数据通路相关

### R型指令

数据通路行为：
- ALU两个输入都来自寄存器堆
- 写回的寄存器为rd
- **不需要Sign-Extend**
- 不需要PC相关计算

典型数据通路信号
| 信号       | 值     |
| -------- | ----- |
| RegDst   | 1（rd） |
| ALUSrc   | 0（rt） |
| MemRead  | 0     |
| MemWrite | 0     |
| MemtoReg | 0     |
| RegWrite | 1     |


“三个寄存器参与运算（或控制），不用立即数” → R 型

R型的op字段均为0，具体功能看funct字段

### I型指令

数据通路行为：
- ALU至少有一个输入端来自Sign-Extend后的16位字段
- 写回的寄存器为rt(rd被16位立即数占据了)
- 可能访问内存
- 可能修改PC

| 指令类         | ALUSrc | RegDst |
| ----------- | ------ | ------ |
| addi / andi | 1      | 0      |
| lw          | 1      | 0      |
| sw          | 1      | X      |
| beq         | 0      | X      |


### J型指令

数据通路行为：
- 不经过ALU运算
- 直接用26位地址拼接PC
- 不访问寄存器堆(jal除外)

其为无条件跳转

指令的低26位为接下来要与PC高4位拼接，由于最后还要和低2位拼得到指令地址，因此

因此这26位再左移两位才为需要与PC拼接的值

即如果PC地址为60000，J指令中的target段则为15000，因为15000<<2=60000

### bne、beq指令

注意跳转到的地址为PC+4+(offset<<2)
这里的offset由imm16符号扩展为32位得到，还需要再左移两位(由指令数到跳转的字节数)


| 信号       | beq | bne | 说明    |
| -------- | --- | --- | ----- |
| Branch   | 1   | 1   | 都是分支  |
| ALUSrc   | 0   | 0   | 比较寄存器 |
| ALUOp    | SUB | SUB | 做减法   |
| RegWrite | 0   | 0   | 不写寄存器 |
| MemRead  | 0   | 0   | 不访存   |


这里有
\[
    BranchTaken=Branch&(ZF\oplus isBne)
\]

这样理解，对于bne，两数不同时跳转，这时ZF=0，isBne=1，因此BranchTaken=1，跳转

对于beq，两数相同时跳转，这时ZF=1，isBne=0，则BranchTaken=1，跳转

### 常见的转发

1. EX/MEM->EX

```
add $t0, $t1, $t2
sub $t3, $t0, $t4
```

- `add`的结果在EX结束时产生
- 存在EX/MEM寄存器中
- 直接转发到下一条的EX

2. MEM/WB->EX

```
lw  $t0, 0($t1)
add $t2, $t0, $t3
```

- `lw`的数据在MEM结束才出来
- 保存在MEM/WB寄存器
- 下一拍转发到EX

这里必须要有一个stall，因为如果按原来顺序，EX时MEM无法取得值

